const path = require('path')
const webpack = require('webpack')
const WexExtManifestPlugin = require('./WexExtManifestPlugin')
const WebExtensionTarget = require('webpack-target-webextension')

module.exports = (opts = {}) => neutrino => {
  const argv = require('yargs-parser')(process.argv.slice(2))
  const isDev = process.env.NODE_ENV === 'development'
  const isProd = process.env.NODE_ENV === 'production'

  const options = {
    polyfill: false,
    removePolyfillSourcemap: isProd,
    template: path.resolve(__dirname, '../template.ejs'),
    manifest: path.resolve(neutrino.options.root, 'src', 'manifest'),
    setup: '',
    ...opts
  }

  if (options.polyfill === true) {
    options.polyfill =
      'node_modules/webextension-polyfill/dist/browser-polyfill.min.js'
  }

  ;['polyfill', 'template', 'manifest', 'setup'].forEach(key => {
    if (options[key] && !path.isAbsolute(options[key])) {
      options[key] = path.resolve(neutrino.options.root, options[key])
    }
  })

  const backgroundEntry = Object.keys(neutrino.options.mains).find(name => {
    const { webext } = neutrino.options.mains[name]
    return webext && webext.type === 'background'
  })

  Object.entries(neutrino.options.mains).forEach(([name, { webext }]) => {
    if (isProd) {
      if (webext && webext.type === 'background') {
        // add fallbacks
        neutrino.config
          .entry(name)
          .prepend(require.resolve('webpack-target-webextension/lib/background'))
      }
      
      if (
        webext &&
        webext.type &&
        /^(content_scripts|background|pageless)$/.test(webext.type)
      ) {
        // remove plugins generated by web preset
        neutrino.config.plugins.delete(`html-${name}`)
        return
      }

      if (options.polyfill) {
        neutrino.config.plugin(`html-${name}`).tap(args => {
          /* istanbul ignore else: web preset should always add options */
          if (args[0]) {
            args[0].webextPolyfill = options.polyfill
            args[0].template = options.template
          }
          return args
        })
      }
    }

    if (isDev) {
      // if you want to keep all the entries but open to a specific path
      // use webpack-dev-server cli option --open-page [entry name].html
      if (
        name !== backgroundEntry &&
        argv.wextentry &&
        argv.wextentry !== name
      ) {
        neutrino.config.entryPoints.delete(name)
        neutrino.config.plugins.delete(`html-${name}`)
        return
      }

      const isBackground = backgroundEntry === name

      neutrino.config
        .entry(name)
        .when(webext && webext.setup, config =>
          config.prepend(
            path.isAbsolute(webext.setup)
              ? webext.setup
              : path.resolve(neutrino.options.source, webext.setup)
          )
        )
        .when(options.setup, config => config.prepend(options.setup))
        .prepend(
          `webextensions-emulator/dist/${isBackground ? 'background' : 'core'}`
        )
        .end()
        .when(
          isBackground,
          config => config.plugins.delete(`html-${name}`),
          config => {
            if (backgroundEntry) {
              // load background with other entries
              config.plugin(`html-${name}`).tap(args => {
                /* istanbul ignore else: web preset should always add options */
                if (args[0]) {
                  args[0].inject = false // manual inject
                  args[0].webextBackground = backgroundEntry

                  const { setup } = neutrino.options.mains[
                    backgroundEntry
                  ].webext
                  if (setup) {
                    args[0].chunks.push(
                      path.isAbsolute(setup)
                        ? setup
                        : path.resolve(neutrino.options.source, setup)
                    )
                  }

                  args[0].chunks.push(backgroundEntry)
                  args[0].template = path.resolve(
                    __dirname,
                    '../template.dev.ejs'
                  )
                }
                return args
              })
            }
          }
        )
    }
  })

  if (isDev) {
    const entry = argv.wextentry
      ? argv.wextentry
      : Object.keys(neutrino.options.mains).find(
          entry => entry !== backgroundEntry
        )
    neutrino.config.optimization
      .clear()
      .end()
      .devServer.index(`${entry}.html`)
  }

  if (isProd) {
    neutrino.config
      .plugin('webext')
      .use(WexExtManifestPlugin, [options, neutrino.options])
      
    // remove babel dynamic import transformation
    neutrino.config.module
      .rule('compile')
      .use('babel')
      .tap(options => {
        options.plugins = options.plugins.filter(
          plugin => !(Array.isArray(plugin) ? plugin[0] : plugin).includes(
            '@babel/plugin-syntax-dynamic-import'
          )
        )
        return options
      })

    // https://v4.webpack.js.org/configuration/resolve/#resolvemainfields
    neutrino.config.resolve
      .mainFields
        .clear()
        .merge(['browser', 'module', 'main'])
        .end()
      .aliasFields
        .clear()
        .merge(['browser'])

    neutrino.config.output.globalObject('self')

    // support native dynamic import
    neutrino.config.target(WebExtensionTarget(neutrino.config.node.entries()))
  }

  if (neutrino.config.module.rules.has('lint')) {
    neutrino.config.module
      .rule('lint')
      .use('eslint')
      .tap(options => {
        if (options.globals) {
          options.globals.push('browser')
        } else {
          options.globals = ['browser']
        }
        return options
      })
  }
  
  if (argv.debug) {
    neutrino.config
      .devtool('inline-source-map')
      .optimization
        .minimize(false)
        .end()
      .plugin('process.env.DEBUG')
        .use(webpack.DefinePlugin, [{
          'process.env.DEBUG': JSON.stringify(!!argv.debug)
        }])
  }
}
